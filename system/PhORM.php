<?php
namespace system;
require_once("MDB2.php");

/*
 * Created on Dec 29, 2010
 * John Barlow
 * 
 * PhORM - PholdBox ORM
 *  
 *  The only requirement for PhORM is that every table that is managed by PhORM
 *  have an "id" field that is an auto increment.  This limitation should fit within 90% 
 *  of the applications written in the framework.  I know this could require your tables 
 *  to be a bit larger than they need to be, but it greatly simplifies the ORM logic.  
 *  Besides, if you want to do something more complex (and horribly inefficient) like 
 *  using UUID's for ID fields, or remove my one extra column you need for PhORM, go ahead...
 *  roll your own.  I'm not stopping you :).
 *
 * 	ORM definitions are configured within the ORM array.
 *	
 *	$ORM - dsn - new dsn if not using default system dsn.  Specifying an invalid DSN
 				WILL make your page hang.
 *		   tableName - Database Table
 *		   columns - Array of column names.
 *		   types - Array of column types.
 *		   values - Associative array of values.
 *		   links - defines linked items - ManytoOne, OnetoMany, OnetoOne.
 * 
 */
 //TODO: set up links logic
 class PhORM extends PholdBoxBaseObj
 {
 	protected $ORM = array();
 	protected $db = null;
 
 	function __construct()
 	{
 		$current_dsn="";
 		$this->SYSTEM = $GLOBALS["SYSTEM"];
 		if(array_key_exists("dsn", $this->ORM) && $this->ORM["dsn"] != "")
 		{
 			$current_dsn = $this->ORM["dsn"];
 		}
 		else
 		{
 			$current_dsn = $this->SYSTEM["dsn"]["default"]; 
 		}
 		
 		$this->db = \MDB2::connect($this->SYSTEM["dsn"][$current_dsn]["connection_string"]);
 		
 		if(\PEAR::isError($this->db))
 		{
 			die($this->db->getMessage());
 		}
 		parent::__construct();
 	}
 	
 	/**
 		Name: setValue
 		
 		Does: Sets value of key into the VO
 		
 		Returns: Nothing
 	*/
 	public function setValue($key, $value)
 	{
 		$this->ORM["values"][$key] = $value;
 	}
 	
 	/**
 		Name: getValue
 		
 		Does: Gets value of key into the VO
 		
 		Returns: value
 	*/
 	public function getValue($key)
 	{
 		if(array_key_exists($key, $this->ORM["values"]))
 		{ 
 			return $this->ORM["values"][$key];
 		}
 		else
 		{
 			return '';
 		}
 	}
 	
 	/**
 		Name: __call
 		
 		Does: This is a php 5 "magic" function that gets called if you call a function that doesn't exist.
 		      The purpose of this is to handle calling "get<value>".  If it doesn't find a key in the object,
 		      it passes the call up to the parent to be handled.
 		      
 		Returns: db value of object, or whatever the parent decides to return (could be an object)
 	*/
 	public function __call($name, $arguments)
 	{
 		$action = substr($name, 0, 3);
 		$prop = lcfirst(substr($name, 3));
 		if($action == "get")
 		{
 			if(in_array($prop, $this->ORM["columns"]))
 			{
 				return $this->getValue($prop);
 			}
 			else
 			{
 				return parent::__call($name, $arguments);
 			}
 		}
 		else if($action == "set")
 		{
 			if(in_array($prop, $this->ORM["columns"]))
 			{
 				$this->setValue($prop, $arguments[0]);
 			}
 			else
 			{
 				parent::__call($name, $arguments);
 			}
 		}
 	}
 	
 	/**
 	 * Name: getPhormTable
 	 * Does: returns the table this object is associated with.
 	 */
 	public function getPhORMTable()
 	{
 		return $this->ORM["tableName"];
 	}

	/**
		Name: generateSelect()
		
		Does: Generates a select statement based on the values in the DB object.  The where clause is 
		      generated by ANDing the values of the object together.
		
		Returns: SQL select statement (string)
	*/ 
 	protected function generateSelect()
 	{
 		$sql = "select ";
 		$first = true; 
 		$wFirst = true;
 		$where = "";
 		foreach($this->ORM["columns"] as $column)
 		{
 			if(!$first)
 			{
 			 	$sql = $sql . ", ";
 			}
 			$sql = $sql . $column;
 			$first=false;
 			if(array_key_exists($column, $this->ORM["values"]) && $this->ORM["values"][$column] != '')
 			{
 				if(!$wFirst)
 				{
 					$where = $where . " and ";
 				}
 				$where = $where . $column . "='" . $this->ORM["values"][$column] . "'";
 				$wFirst = false;
 			}
 		}
 		$sql = $sql . " from " . $this->ORM["tableName"];
 		if($where != '')
 		{
 			$sql = $sql . " where " . $where;
 		}
 		
 		return $sql;
 	}
 	
 	//this function assumes 1 row is being returned, and will use the fist one it finds.
 	public function load()
 	{
 		if($this->getId() == '')
 		{
 			die("PhORM Error: id must be specified");
 		}
 		
 		$sql = $this->generateSelect();	
 		
 		$result = $this->db->query($sql);
 		
 		// Always check that result is not an error
		if (\PEAR::isError($result)) {
		    die($result->getMessage());
		}
		
		//load object
		if($result->numRows() > 0)
		{
			$row = $result->fetchRow();
			$colIndex = 0;
			foreach($result->getColumnNames(true) as $column)
			{
				$this->setValue($column, $row[$colIndex]);
				$colIndex++;
			}
 		}
 		else
 		{
 			$this->setValue("id", "");
 		} 		
 	}
 	
 	protected function generateUpdate()
 	{
 		$sql = "update ". $this->ORM["tableName"] . " set ";
 		$first = true;
 		
 		foreach($this->ORM["columns"] as $column)
 		{	
 			if($column != "id")
 			{
 				//sanity check
 				if(!array_key_exists($column, $this->ORM["values"]))
 				{
 					print(get_class($this) . " - Missing value: $column");
 					exit;
 				}
 				
	 			if(!$first)
	 			{
	 			 	$sql = $sql . ", ";
	 			}
	 			$sql = $sql . $column . " = '" . $this->ORM["values"][$column] . "'";
	 			$first=false;
 			}
 			
 		}
 		
 		$sql = $sql . " where id = " . $this->ORM["values"]["id"] . ";";
 		
 		return $sql;
 	}
 	
 	protected function generateInsert()
 	{
 		$sql = "insert into ". $this->ORM["tableName"];
 		$first = true;
 		$colNames = " (";
 		$values = " values (";
 		foreach($this->ORM["columns"] as $column)
 		{	
 			if($column != "id")
 			{
 				//sanity check
 				if(!array_key_exists($column, $this->ORM["values"]))
 				{
 					print(get_class($this) . " - Missing value: $column");
 					exit;
 				}
 				
	 			if(!$first)
	 			{
	 			 	$colNames = $colNames . ", ";
	 			 	$values = $values . ", ";
	 			}
	 			
	 			//$colNames = $colNames . "'" . $column . "'";
	 			$colNames = $colNames . $column;
	 			$values = $values . "'" . $this->ORM["values"][$column] . "'";
	 			$first=false;
 			}
 			
 		}
 		$colNames = $colNames . ")";
 		$values = $values . ")";
 		$sql = $sql . $colNames . $values . ";";
 		
 		return $sql;
 	}
 	
 	//TODO: Finish this
 	protected function generateBulkInsert($tempTableKey)
 	{
 		$target = '';
 		$sql = '';
 		
 		if($tempTableKey != null)
 		{
 			$sql .= $this->generateTempTableSQL($tempTableKey);
 			$target = $tempTableKey;
 		}
 		else
 		{
 			$target = $this->ORM["tableName"];
 		}
 		
 		$sql .= "insert into ". $target;
 		$first = true;
 		$colNames = " (";
 		foreach($this->ORM["columns"] as $column)
 		{	
 			if($column != "id" || $tempTableKey != null)
 			{
 				//sanity check
 				if(!array_key_exists($column, $this->ORM["values"]))
 				{
 					print(get_class($this) . " - Missing value: $column");
 					exit;
 				}
 				
	 			if(!$first)
	 			{
	 			 	$colNames = $colNames . ", ";
	 			}
	 			
	 			$colNames = $colNames . $column;
	 			$first=false;
 			}
 			
 		}
 		$colNames = $colNames . ")";
 		$sql = $sql . $colNames;
 		
 		return $sql;
 	}
 	
 	/**
 	 * Name: generateTempTableSQL
 	 * Does: Generates the temp table creation SQL for whatever DB server you are using
 	 * @param string tempTableKey - name of temporary table.
 	 * @return string SQL to create temp table.
 	 */
 	protected function generateTempTableSQL($tempTableKey)
 	{	
 		$sql = "";
 		//TODO: do some fancy switching here based on db type
 		
 		//MYSQL
 		$sql = "CREATE TEMPORARY TABLE ". $tempTableKey . " (";
    	$count = 0;
    	
    	foreach($this->ORM["columns"] as $column)
    	{
    		if($count != 0)
    		{ 
    			$sql .= ", ";
    		}
    		$sql .= $column . " " . $this->ORM["types"][$count];
    		$count++;
    	}
    	$sql .= ");";
   
 		return $sql;	
 	}
 	
 	/**
 	 * Name: generateBulkSelect
 	 * Does: creates the select statements needed for bulk inserting
 	 */
 	protected function generateBulkSelect($tempTableKey)
 	{
 		$sql = "Select ";
 		$first = true;
 		foreach($this->ORM["columns"] as $column)
 		{	
 			if($column != "id" || $tempTableKey != null)
 			{
 				//sanity check
 				if(!array_key_exists($column, $this->ORM["values"]))
 				{
 					print(get_class($this) . " - Missing value: $column");
 					exit;
 				}
 				
	 			if(!$first)
	 			{
	 			 	$sql = $sql . ", ";
	 			}
	 			
	 			$sql = $sql . "'" . $this->ORM["values"][$column] . "'";
	 			$first=false;
 			}
 			
 		}
 		//$sql = $sql . ";";
 		
 		return $sql;
 	}
 	
 	/**
 	 * Name: Save
 	 * 
 	 * Does: Saves the object based on the values.  If an ID is given, it will update instead 
 	 * of insert.
 	 */
 	public function save()
 	{
 		$sql = "";
 		if(array_key_exists("id", $this->ORM["values"]) && $this->ORM["values"]["id"] != "")
 		{
 			//if the id is defined, update
 			$sql = $this->generateUpdate();
 		}
 		//else, if the id is not defined, insert.
 		else
 		{
 			$sql = $this->generateInsert();
 		}
 		
 		$result = $this->db->exec($sql);
 		
 		// Always check that result is not an error
		if (\PEAR::isError($result)) {
		    die($result->getMessage());
		}
 		return $result;
 	}
 	
 	/**
 	 * Name: Delete
 	 * 
 	 * Does: removes record from db based on the values in the object
 	 */
 	public function delete()
 	{
 		$sql = "delete from ". $this->ORM["tableName"];
 		//sanity check
 		
		if(!array_key_exists("id", $this->ORM["values"]) || $this->ORM["values"]["id"] == "")
		{
			print(get_class($this) . " - id is undefined");
			exit;
		}
 		$sql = $sql . " where id='". $this->ORM["values"]["id"] ."'";
 				
 		print($sql);
 	}
 	
 	
 	//TODO: create getlist? Function
 	
 	//TODO: create cascade Save Function? (make it queue up queries and send as one)
 	
 	//TODO: finish bulkSave
 	public function bulkSave($items)
 	{
 		$insertSQL = "";
 		$updateSQL = "";
 		$insertCount = 0;
 		$updateCount = 0;
 		$result = array();
 		$table = "";
 		$tempTableKey = "TempTableKey";
 		
 		foreach($items as $item)
 		{
 			//check to make sure the collection is all of the same type
 			if($table == '')
 			{
 				$table = $item->getPhORMTable();
 			}
 			else if($table != $item->getPhORMTable())
 			{
 				die("PhORM Error: Object array in bulkSave not of the same type.");
 			}
 			
	 		if($item->getId() != "")
	 		{
	 			$updateSQL .= $this->generateBulkSaveInsert($updateCount, $item, $tempTableKey);
	 			$updateCount++;
	 			//if the id is defined, update
	 			//$sql = $this->generateUpdate();
	 		}
	 		//else, if the id is not defined, insert.
	 		else
	 		{
	 			$insertSQL .= $this->generateBulkSaveInsert($insertCount, $item);
	 			$insertCount++;
	 		}
	 	}
	    
 		if($insertCount != 0)
 		{
 			$insertSQL .= ";";
	 		$result["insert"] = $this->db->exec($insertSQL);
	 		print($insertSQL);
	 		// Always check that result is not an error
			if (\PEAR::isError($result)) {
			    die($result->getMessage());
			}
		}
		
		if($updateCount != 0)
		{
			$updateSQL .= ";";
			$updateSQL .= $this->generateBulkUpdateJoin($tempTableKey, $table); 
			print($updateSQL);
			/*$result{"update"} = $this->db->exec($updateSQL);
	 		
	 		// Always check that result is not an error
			if (\PEAR::isError($result)) {
			    die($result->getMessage());
			}*/
		}
 		
 	}
 	
 	protected function generateBulkSaveInsert($index, $item, $tempTableKey = null)
 	{
 		$sql = '';
 		if($index == 0)
		{
			$sql = $item->generateBulkInsert($tempTableKey) . " ";
		}
		else
		{
			$sql = $sql . "UNION ALL ";
		}

		$sql = $sql . $item->generateBulkSelect($tempTableKey) . " ";
		return $sql;
 	}
 	
 	protected function generateBulkUpdateJoin($tempTableKey, $itemTable)
 	{
 		$first = true;
 		$sql = "UPDATE " . $itemTable . " oldTable ";
 		$sql .= "INNER JOIN " . $tempTableKey . " newTable ";
 		$sql .= "   ON oldTable.id = newTable.id";
 		$sql .= "   SET ";
 		foreach($this->ORM["columns"] as $column)
 		{
 			if(!$first)
 			{
 				$sql .= ", ";
 			}
 			if(isset($this->ORM["values"][$column]))
 			{
 				$sql .= "oldTable." . $column . " = " . "newTable." . $column;
 				$first = false;
 			}
 		}
 		$sql .= ";DROP TABLE " . $tempTableKey . ";";
 		return $sql;
 	}
 }
?>
